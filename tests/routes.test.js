import chai from 'chai';
import chaiHttp from 'chai-http';
import server from '../server'; // Adjust the path to your server file
import sinon from 'sinon';
import AppController from '../controllers/AppController';
import dbClient from '../utils/db';
import redisClient from '../utils/redis';
import sha1 from 'sha1';

const should = chai.should();

chai.use(chaiHttp);
/* eslint-disable */
describe('Routes', () => {
  // Example test case

//   Inside server.js, create the Express server:

// it should listen on the port set by the environment variable PORT or by default 5000
// it should load all routes from the file routes/index.js
// Inside the folder routes, create a file index.js that contains all endpoints of our API:

// GET /status => AppController.getStatus
// GET /stats => AppController.getStats
// Inside the folder controllers, create a file AppController.js that contains the definition of the 2 endpoints:

// GET /status should return if Redis is alive and if the DB is alive too by using the 2 utils created previously: { "redis": true, "db": true } with a status code 200
// GET /stats should return the number of users and files in DB: { "users": 12, "files": 1231 } with a status code 200
// users collection must be used for counting all users
// files collection must be used for counting all files
describe('Routes', () => {
  describe('GET /status', () => {
    it('it should return the status of Redis and DB', (done) => {
      const redisStub = sinon.stub(redisClient, 'isAlive').returns(true);
      const dbStub = sinon.stub(dbClient, 'isAlive').returns(true);

      chai.request(server)
        .get('/status')
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a('object');
          res.body.should.have.property('redis').eql(true);
          res.body.should.have.property('db').eql(true);
          redisStub.restore();
          dbStub.restore();
          done();
        });
    });
  });

  describe('GET /stats', () => {
    it('it should return the number of users and files in DB', (done) => {
      const usersCountStub = sinon.stub(dbClient, 'nbUsers').returns(12);
      const filesCountStub = sinon.stub(dbClient, 'nbFiles').returns(1231);

      chai.request(server)
        .get('/stats')
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a('object');
          res.body.should.have.property('users').eql(12);
          res.body.should.have.property('files').eql(1231);
          usersCountStub.restore();
          filesCountStub.restore();
          done();
        });
    });
  });

// Now that we have a simple API, itâ€™s time to add users to our database.

// In the file routes/index.js, add a new endpoint:

// POST /users => UsersController.postNew
// Inside controllers, add a file UsersController.js that contains the new endpoint:

// POST /users should create a new user in DB:

// To create a user, you must specify an email and a password
// If the email is missing, return an error Missing email with a status code 400
// If the password is missing, return an error Missing password with a status code 400
// If the email already exists in DB, return an error Already exist with a status code 400
// The password must be stored after being hashed in SHA1
// The endpoint is returning the new user with only the email and the id (auto generated by MongoDB) with a status code 201
// The new user must be saved in the collection users:
// email: same as the value received
// password: SHA1 value of the value received
describe('POST /users', () => {
  it('it should not create a user without email', (done) => {
    const user = {
      password: '123456'
    };
    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing email');
        done();
      });
  });

  it('it should not create a user without password', (done) => {
    const user = {
      email: 'test@example.com'
    };
    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing password');
        done();
      });
  });

  it('it should not create a user with an existing email', (done) => {
    const user = {
      email: 'test@example.com',
      password: '123456'
    };
    const emailExistsStub = sinon.stub(dbClient, 'findUserByEmail').returns(true);

    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Already exist');
        emailExistsStub.restore();
        done();
      });
  });

  it('it should create a user with valid email and password', (done) => {
    const user = {
      email: 'test@example.com',
      password: '123456'
    };
    const emailExistsStub = sinon.stub(dbClient, 'findUserByEmail').returns(false);
    const addUserStub = sinon.stub(dbClient, 'addUser').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });

    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(201);
        res.body.should.be.a('object');
        res.body.should.have.property('id');
        res.body.should.have.property('email').eql('test@example.com');
        emailExistsStub.restore();
        addUserStub.restore();
        done();
      });
  });
});
});

// In the file routes/index.js, add 3 new endpoints:

// GET /connect => AuthController.getConnect
// GET /disconnect => AuthController.getDisconnect
// GET /users/me => UserController.getMe
// Inside controllers, add a file AuthController.js that contains new endpoints:

// GET /connect should sign-in the user by generating a new authentication token:

// By using the header Authorization and the technique of the Basic auth (Base64 of the <email>:<password>), find the user associate to this email and with this password (reminder: we are storing the SHA1 of the password)
// If no user has been found, return an error Unauthorized with a status code 401
// Otherwise:
// Generate a random string (using uuidv4) as token
// Create a key: auth_<token>
// Use this key for storing in Redis (by using the redisClient create previously) the user ID for 24 hours
// Return this token: { "token": "155342df-2399-41da-9e8c-458b6ac52a0c" } with a status code 200
// Now, we have a way to identify a user, create a token (= avoid to store the password on any front-end) and use this token for 24h to access to the API!

// Every authenticated endpoints of our API will look at this token inside the header X-Token.

// GET /disconnect should sign-out the user based on the token:

// Retrieve the user based on the token:
// If not found, return an error Unauthorized with a status code 401
// Otherwise, delete the token in Redis and return nothing with a status code 204
// Inside the file controllers/UsersController.js add a new endpoint:

// GET /users/me should retrieve the user base on the token used:

// Retrieve the user based on the token:
// If not found, return an error Unauthorized with a status code 401
// Otherwise, return the user object (email and id only)
describe('GET /connect', () => {
  it('it should not sign in with invalid credentials', (done) => {
    const credentials = Buffer.from('invalid@example.com:wrongpassword').toString('base64');
    chai.request(server)
      .get('/connect')
      .set('Authorization', `Basic ${credentials}`)
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should sign in with valid credentials', (done) => {
    const credentials = Buffer.from('test@example.com:123456').toString('base64');
    const findUserByEmailStub = sinon.stub(dbClient, 'findUserByEmail').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com',
      password: sha1('123456'),
    });
    const redisSetStub = sinon.stub(redisClient, 'set').returns(true);

    chai.request(server)
      .get('/connect')
      .set('Authorization', `Basic ${credentials}`)
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('object');
        res.body.should.have.property('token');
        findUserByEmailStub.restore();
        redisSetStub.restore();
        done();
      });
  });
});

describe('GET /disconnect', () => {
  it('it should not sign out without a valid token', (done) => {
    chai.request(server)
      .get('/disconnect')
      .set('X-Token', 'invalidtoken')
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should sign out with a valid token', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const redisDelStub = sinon.stub(redisClient, 'del').returns(true);

    chai.request(server)
      .get('/disconnect')
      .set('X-Token', token)
      .end((err, res) => {
        res.should.have.status(204);
        redisGetStub.restore();
        redisDelStub.restore();
        done();
      });
  });
});

describe('GET /users/me', () => {
  it('it should not retrieve user without a valid token', (done) => {
    chai.request(server)
      .get('/users/me')
      .set('X-Token', 'invalidtoken')
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should retrieve user with a valid token', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });

    chai.request(server)
      .get('/users/me')
      .set('X-Token', token)
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('object');
        res.body.should.have.property('id').eql('507f1f77bcf86cd799439011');
        res.body.should.have.property('email').eql('test@example.com');
        redisGetStub.restore();
        findUserByIdStub.restore();
        done();
      });
  });
});

});
