import chai from 'chai';
import chaiHttp from 'chai-http';
import server from '../server'; // Adjust the path to your server file
import sinon from 'sinon';
import AppController from '../controllers/AppController';
import dbClient from '../utils/db';
import redisClient from '../utils/redis';
import sha1 from 'sha1';

const should = chai.should();

chai.use(chaiHttp);
/* eslint-disable */
describe('Routes', () => {
  // Example test case

//   Inside server.js, create the Express server:

// it should listen on the port set by the environment variable PORT or by default 5000
// it should load all routes from the file routes/index.js
// Inside the folder routes, create a file index.js that contains all endpoints of our API:

// GET /status => AppController.getStatus
// GET /stats => AppController.getStats
// Inside the folder controllers, create a file AppController.js that contains the definition of the 2 endpoints:

// GET /status should return if Redis is alive and if the DB is alive too by using the 2 utils created previously: { "redis": true, "db": true } with a status code 200
// GET /stats should return the number of users and files in DB: { "users": 12, "files": 1231 } with a status code 200
// users collection must be used for counting all users
// files collection must be used for counting all files
describe('Routes', () => {
  describe('GET /status', () => {
    it('it should return the status of Redis and DB', (done) => {
      const redisStub = sinon.stub(redisClient, 'isAlive').returns(true);
      const dbStub = sinon.stub(dbClient, 'isAlive').returns(true);

      chai.request(server)
        .get('/status')
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a('object');
          res.body.should.have.property('redis').eql(true);
          res.body.should.have.property('db').eql(true);
          redisStub.restore();
          dbStub.restore();
          done();
        });
    });
  });

  describe('GET /stats', () => {
    it('it should return the number of users and files in DB', (done) => {
      const usersCountStub = sinon.stub(dbClient, 'nbUsers').returns(12);
      const filesCountStub = sinon.stub(dbClient, 'nbFiles').returns(1231);

      chai.request(server)
        .get('/stats')
        .end((err, res) => {
          res.should.have.status(200);
          res.body.should.be.a('object');
          res.body.should.have.property('users').eql(12);
          res.body.should.have.property('files').eql(1231);
          usersCountStub.restore();
          filesCountStub.restore();
          done();
        });
    });
  });

// Now that we have a simple API, itâ€™s time to add users to our database.

// In the file routes/index.js, add a new endpoint:

// POST /users => UsersController.postNew
// Inside controllers, add a file UsersController.js that contains the new endpoint:

// POST /users should create a new user in DB:

// To create a user, you must specify an email and a password
// If the email is missing, return an error Missing email with a status code 400
// If the password is missing, return an error Missing password with a status code 400
// If the email already exists in DB, return an error Already exist with a status code 400
// The password must be stored after being hashed in SHA1
// The endpoint is returning the new user with only the email and the id (auto generated by MongoDB) with a status code 201
// The new user must be saved in the collection users:
// email: same as the value received
// password: SHA1 value of the value received
describe('POST /users', () => {
  it('it should not create a user without email', (done) => {
    const user = {
      password: '123456'
    };
    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing email');
        done();
      });
  });

  it('it should not create a user without password', (done) => {
    const user = {
      email: 'test@example.com'
    };
    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing password');
        done();
      });
  });

  it('it should not create a user with an existing email', (done) => {
    const user = {
      email: 'test@example.com',
      password: '123456'
    };
    const emailExistsStub = sinon.stub(dbClient, 'findUserByEmail').returns(true);

    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Already exist');
        emailExistsStub.restore();
        done();
      });
  });

  it('it should create a user with valid email and password', (done) => {
    const user = {
      email: 'test@example.com',
      password: '123456'
    };
    const emailExistsStub = sinon.stub(dbClient, 'findUserByEmail').returns(false);
    const addUserStub = sinon.stub(dbClient, 'addUser').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });

    chai.request(server)
      .post('/users')
      .send(user)
      .end((err, res) => {
        res.should.have.status(201);
        res.body.should.be.a('object');
        res.body.should.have.property('id');
        res.body.should.have.property('email').eql('test@example.com');
        emailExistsStub.restore();
        addUserStub.restore();
        done();
      });
  });
});
});

// In the file routes/index.js, add 3 new endpoints:

// GET /connect => AuthController.getConnect
// GET /disconnect => AuthController.getDisconnect
// GET /users/me => UserController.getMe
// Inside controllers, add a file AuthController.js that contains new endpoints:

// GET /connect should sign-in the user by generating a new authentication token:

// By using the header Authorization and the technique of the Basic auth (Base64 of the <email>:<password>), find the user associate to this email and with this password (reminder: we are storing the SHA1 of the password)
// If no user has been found, return an error Unauthorized with a status code 401
// Otherwise:
// Generate a random string (using uuidv4) as token
// Create a key: auth_<token>
// Use this key for storing in Redis (by using the redisClient create previously) the user ID for 24 hours
// Return this token: { "token": "155342df-2399-41da-9e8c-458b6ac52a0c" } with a status code 200
// Now, we have a way to identify a user, create a token (= avoid to store the password on any front-end) and use this token for 24h to access to the API!

// Every authenticated endpoints of our API will look at this token inside the header X-Token.

// GET /disconnect should sign-out the user based on the token:

// Retrieve the user based on the token:
// If not found, return an error Unauthorized with a status code 401
// Otherwise, delete the token in Redis and return nothing with a status code 204
// Inside the file controllers/UsersController.js add a new endpoint:

// GET /users/me should retrieve the user base on the token used:

// Retrieve the user based on the token:
// If not found, return an error Unauthorized with a status code 401
// Otherwise, return the user object (email and id only)
describe('GET /connect', () => {
  it('it should not sign in with invalid credentials', (done) => {
    const credentials = Buffer.from('invalid@example.com:wrongpassword').toString('base64');
    chai.request(server)
      .get('/connect')
      .set('Authorization', `Basic ${credentials}`)
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should sign in with valid credentials', (done) => {
    const credentials = Buffer.from('test@example.com:123456').toString('base64');
    const findUserByEmailStub = sinon.stub(dbClient, 'findUserByEmail').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com',
      password: sha1('123456'),
    });
    const redisSetStub = sinon.stub(redisClient, 'set').returns(true);

    chai.request(server)
      .get('/connect')
      .set('Authorization', `Basic ${credentials}`)
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('object');
        res.body.should.have.property('token');
        findUserByEmailStub.restore();
        redisSetStub.restore();
        done();
      });
  });
});

describe('GET /disconnect', () => {
  it('it should not sign out without a valid token', (done) => {
    chai.request(server)
      .get('/disconnect')
      .set('X-Token', 'invalidtoken')
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should sign out with a valid token', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const redisDelStub = sinon.stub(redisClient, 'del').returns(true);

    chai.request(server)
      .get('/disconnect')
      .set('X-Token', token)
      .end((err, res) => {
        res.should.have.status(204);
        redisGetStub.restore();
        redisDelStub.restore();
        done();
      });
  });
});

describe('GET /users/me', () => {
  it('it should not retrieve user without a valid token', (done) => {
    chai.request(server)
      .get('/users/me')
      .set('X-Token', 'invalidtoken')
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should retrieve user with a valid token', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });

    chai.request(server)
      .get('/users/me')
      .set('X-Token', token)
      .end((err, res) => {
        res.should.have.status(200);
        res.body.should.be.a('object');
        res.body.should.have.property('id').eql('507f1f77bcf86cd799439011');
        res.body.should.have.property('email').eql('test@example.com');
        redisGetStub.restore();
        findUserByIdStub.restore();
        done();
      });
  });
});


// In the file routes/index.js, add a new endpoint:

// POST /files => FilesController.postUpload
// Inside controllers, add a file FilesController.js that contains the new endpoint:

// POST /files should create a new file in DB and in disk:

// Retrieve the user based on the token:
// If not found, return an error Unauthorized with a status code 401
// To create a file, you must specify:
// name: as filename
// type: either folder, file or image
// parentId: (optional) as ID of the parent (default: 0 -> the root)
// isPublic: (optional) as boolean to define if the file is public or not (default: false)
// data: (only for type=file|image) as Base64 of the file content
// If the name is missing, return an error Missing name with a status code 400
// If the type is missing or not part of the list of accepted type, return an error Missing type with a status code 400
// If the data is missing and type != folder, return an error Missing data with a status code 400
// If the parentId is set:
// If no file is present in DB for this parentId, return an error Parent not found with a status code 400
// If the file present in DB for this parentId is not of type folder, return an error Parent is not a folder with a status code 400
// The user ID should be added to the document saved in DB - as owner of a file
// If the type is folder, add the new file document in the DB and return the new file with a status code 201
// Otherwise:
// All file will be stored locally in a folder (to create automatically if not present):
// The relative path of this folder is given by the environment variable FOLDER_PATH
// If this variable is not present or empty, use /tmp/files_manager as storing folder path
// Create a local path in the storing folder with filename a UUID
// Store the file in clear (reminder: data contains the Base64 of the file) in this local path
// Add the new file document in the collection files with these attributes:
// userId: ID of the owner document (owner from the authentication)
// name: same as the value received
// type: same as the value received
// isPublic: same as the value received
// parentId: same as the value received - if not present: 0
// localPath: for a type=file|image, the absolute path to the file save in local
// Return the new file with a status code 201
describe('POST /files', () => {
  afterEach(function(){
    sinon.restore();
  });

  it('it should not create a file without a valid token', (done) => {
    chai.request(server)
      .post('/files')
      .send({})
      .end((err, res) => {
        res.should.have.status(401);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Unauthorized');
        done();
      });
  });

  it('it should not create a file without name', (done) => {
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
     _id: '507f1f77bcf86cd799439011',
     email: 'test@example.com'
   });
    const token = 'validtoken';
    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ type: 'file', data: 'dGVzdA==' })
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing name');
        done();
      });
  });

  it('it should not create a file without type', (done) => {
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
     _id: '507f1f77bcf86cd799439011',
     email: 'test@example.com'
   });
    const token = 'validtoken';
    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfile', data: 'dGVzdA==' })
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing type');
        done();
      });
  });

  it('it should not create a file without data for type file', (done) => {
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
     _id: '507f1f77bcf86cd799439011',
     email: 'test@example.com'
   });
    const token = 'validtoken';
    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfile', type: 'file' })
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Missing data');
        done();
      });
  });

  it('it should not create a file with invalid parentId', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });
    const findFileByIdStub = sinon.stub(dbClient, 'findFileById').returns(null);

    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfile', type: 'file', data: 'dGVzdA==', parentId: 'invalidId' })
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Parent not found');
        redisGetStub.restore();
        findFileByIdStub.restore();
        done();
      });
  });

  it('it should not create a file if parent is not a folder', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });
    const findFileByIdStub = sinon.stub(dbClient, 'findFileById').returns({ type: 'file' });

    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfile', type: 'file', data: 'dGVzdA==', parentId: '507f1f77bcf86cd799439011' })
      .end((err, res) => {
        res.should.have.status(400);
        res.body.should.be.a('object');
        res.body.should.have.property('error').eql('Parent is not a folder');
        redisGetStub.restore();
        findFileByIdStub.restore();
        done();
      });
  });

  it('it should create a folder with valid data', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });
    const addFileStub = sinon.stub(dbClient, 'addFile').returns({
      _id: '507f1f77bcf86cd799439011',
      name: 'testfolder',
      type: 'folder',
      userId: '507f1f77bcf86cd799439011',
      isPublic: false,
      parentId: '0'
    });

    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfolder', type: 'folder' })
      .end((err, res) => {
        res.should.have.status(201);
        res.body.should.be.a('object');
        res.body.should.have.property('id');
        res.body.should.have.property('name').eql('testfolder');
        res.body.should.have.property('type').eql('folder');
        redisGetStub.restore();
        addFileStub.restore();
        done();
      });
  });

  it('it should create a file with valid data', (done) => {
    const token = 'validtoken';
    const redisGetStub = sinon.stub(redisClient, 'get').returns('507f1f77bcf86cd799439011');
    const findUserByIdStub = sinon.stub(dbClient, 'findUserById').returns({
      _id: '507f1f77bcf86cd799439011',
      email: 'test@example.com'
    });
    const addFileStub = sinon.stub(dbClient, 'addFile').returns({
      _id: '507f1f77bcf86cd799439011',
      name: 'testfile',
      type: 'file',
      userId: '507f1f77bcf86cd799439011',
      isPublic: false,
      parentId: '0',
      localPath: '/tmp/files_manager/507f1f77bcf86cd799439011'
    });

    chai.request(server)
      .post('/files')
      .set('X-Token', token)
      .send({ name: 'testfile', type: 'file', data: 'dGVzdA==' })
      .end((err, res) => {
        res.should.have.status(201);
        res.body.should.be.a('object');
        res.body.should.have.property('id');
        res.body.should.have.property('name').eql('testfile');
        res.body.should.have.property('type').eql('file');
        res.body.should.have.property('localPath');
        redisGetStub.restore();
        addFileStub.restore();
        done();
      });
  });
});
});
